---
title: n个无序数求第k大的数
date: 2018-03-15 22:52:29
tags: 算法
---

> 今天面试问到n个无序的库找出第k大的数，用最优的算法，想了半天只后只好回答用快速排序再求第k大的数，时间复杂度为O(nlogn)，但这显然不是最优算法，回来后查了一个，在此做个记录。主要参考: [寻找第k大的数](https://www.jianshu.com/p/33ee33ce8699)

## 排序解决法

排序再找第k大的数是最简单的解决方法，排序完成后再找只需要根据数据索引即可，时间复杂度是1

而排序最优的是快速排序(不能绝对的，与数组大小有关)，时间复杂度为O(nlogn)，所以最后的时间复杂度O(nlogn)

快速排序基本思想是数组中取任意一个值key，将大于key的值放在key右边，小于key的值放在key左边。key的左边和右边则都是有序的了，然后递归key值左右的子数组。具体代码见参考文章。


## 类快排解法

采取快速排序的思想，快速排序中一个最重要的partition算法是这样的。
>快速排序基本思想是数组中取任意一个值key，将大于key的值放在key右边，小于key的值放在key左边。key的左边和右边则都是有序的了

快排中的partition算法，返回key在数组中的位置，如果key的位置正好等于k-1，那么问题则得到解决，如果key的位置不等于k-1，可使用递归查找对应子数组。直到key的位置等于k-1，则找对问题的解。

此解法的效率值为N*lgK，由于K是常数，所以此解法效率值为N，优于排序解法

通俗的描述一下partition的过程

1. 长度为n的数组，取出第1个数作为参考值m，从第n个数向前遍历
2. 如果数小于m则将该数放到第一个数的位置，并记下索引j
3. 再从第2个数向后遍历，如果数大于m，则将该数放到数组索引j的位置，并记下该数的索引i
4. 再从数组索引j-1的位置向前遍历，如果数小于m，将该数放到数组索引i的位置，并记下此时的索引j
5. 再次从i+1的位置向后遍历，循环3-4
6. 最后空的就是m的位置，而且m左边的比m小，右边的比m大

## 最小堆解法

该方法还未了解，以后再补充